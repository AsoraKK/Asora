#!/usr/bin/env node
const fs = require('node:fs');
const path = require('node:path');

const distDir = path.join(__dirname, '..', 'dist');
const srcEntry = path.join(distDir, 'src', 'index.js');
const destEntry = path.join(distDir, 'index.js');
const srcTypes = path.join(distDir, 'src', 'index.d.ts');
const destTypes = path.join(distDir, 'index.d.ts');
const banner = '// Auto-generated by scripts/write-dist-entry.cjs\n';

if (!fs.existsSync(srcEntry)) {
  console.error('Expected build output missing at', srcEntry);
  process.exit(1);
}

fs.mkdirSync(distDir, { recursive: true });

// Generated entrypoint: prefer the compiled bootstrap, but fall back to
// direct per-route requires if that fails so /api/health still comes up.
const fallbackModules = [
  './src/shared/routes/ready',
  './src/feed/routes/getFeed',
  './src/feed/routes/createPost',
  './src/auth/routes/authorize',
  './src/auth/routes/getConfig',
  './src/auth/routes/ping',
  './src/auth/routes/token',
  './src/auth/routes/userinfo',
  './src/moderation/routes/flagContent',
  './src/moderation/routes/submitAppeal',
  './src/moderation/routes/voteOnAppeal',
  './src/privacy/routes/deleteUser',
  './src/privacy/routes/exportUser',
];

const jsContent = `${banner}(function bootstrap() {
  const modules = ${JSON.stringify(fallbackModules)};
  let bootstrapLoaded = false;

  try {
    require('./src/index.js');
    bootstrapLoaded = true;
  } catch (error) {
    const reason = error && error.message ? error.message : error;
    console.error('[bootstrap] Failed to load ./src/index.js:', reason);

    for (const mod of modules) {
      try {
        require(mod);
        console.log('[bootstrap] Loaded fallback module:', mod);
      } catch (moduleError) {
        const detail = moduleError && moduleError.message ? moduleError.message : moduleError;
        console.error('[bootstrap] Failed to load fallback module', mod + ':', detail);
      }
    }
  }

  if (!bootstrapLoaded) {
    console.error('[bootstrap] Falling back to per-route requires; verify readiness endpoints separately.');
  }
})();\n`;
fs.writeFileSync(destEntry, jsContent, 'utf8');

if (fs.existsSync(srcTypes)) {
  const typesContent = `${banner}export * from './src/index';\n`;
  fs.writeFileSync(destTypes, typesContent, 'utf8');
}

// Copy required Azure Functions files to dist root
const rootDir = path.join(__dirname, '..');
const filesToCopy = ['host.json', 'package.json'];

for (const file of filesToCopy) {
  const srcPath = path.join(rootDir, file);
  const destPath = path.join(distDir, file);

  if (fs.existsSync(srcPath)) {
    if (file === 'package.json') {
      // Create a clean production package.json for deployment
      // - Set main to index.js
      // - Force type to commonjs (critical for Azure Functions Flex)
      // - Include only essential fields
      const pkg = JSON.parse(fs.readFileSync(srcPath, 'utf8'));
      const prodPkg = {
        name: pkg.name,
        version: pkg.version,
        private: true,
        type: 'commonjs',
        main: 'index.js',
        engines: pkg.engines,
        dependencies: pkg.dependencies
      };
      fs.writeFileSync(destPath, JSON.stringify(prodPkg, null, 2) + '\n', 'utf8');
      console.log(`Copied ${file} to dist/ (production CJS package)`);
    } else {
      fs.copyFileSync(srcPath, destPath);
      console.log(`Copied ${file} to dist/`);
    }
  } else {
    console.warn(`Warning: ${file} not found in root directory`);
  }
}

// Generate a classic health function fallback (function.json + handler) so the
// platform can always serve /api/health even if worker indexing or the v4
// programming model bootstrap fails during cold start.
const fallbackDir = path.join(distDir, 'health');
fs.mkdirSync(fallbackDir, { recursive: true });

const functionJson = {
  bindings: [
    {
      authLevel: 'anonymous',
      type: 'httpTrigger',
      direction: 'in',
      name: 'req',
      methods: ['get'],
      route: 'health',
    },
    {
      type: 'http',
      direction: 'out',
      name: 'res',
    },
  ],
};
fs.writeFileSync(path.join(fallbackDir, 'function.json'), JSON.stringify(functionJson, null, 2) + '\n', 'utf8');

const fallbackHandler = `const HEADERS = {
  'Content-Type': 'application/json',
  'Cache-Control': 'no-store, no-cache, must-revalidate',
};

function resolveCommit() {
  const raw = typeof process.env.GIT_SHA === 'string' ? process.env.GIT_SHA.trim() : '';
  return raw || 'unknown';
}

module.exports = async function healthFallback(context) {
  let commit = 'unknown';

  try {
    commit = resolveCommit();
  } catch (error) {
    console.error('[health-fallback] Failed to resolve commit:', error instanceof Error ? error.message : error);
  }

  const payload = { status: 'ok', commit };

  context.res = {
    status: 200,
    headers: HEADERS,
    body: JSON.stringify(payload),
  };
};

module.exports.health = module.exports;
module.exports.default = module.exports;
`;
fs.writeFileSync(path.join(fallbackDir, 'index.js'), fallbackHandler, 'utf8');

console.log('Generated classic fallback health function at dist/health/');

function pruneTestArtifacts(currentDir) {
  if (!fs.existsSync(currentDir)) {
    return;
  }

  for (const entry of fs.readdirSync(currentDir, { withFileTypes: true })) {
    const fullPath = path.join(currentDir, entry.name);

    if (entry.isDirectory()) {
      if (entry.name === '__tests__') {
        fs.rmSync(fullPath, { recursive: true, force: true });
        continue;
      }

      pruneTestArtifacts(fullPath);
      continue;
    }

    if (/\.test\.[cm]?js$/.test(entry.name) || /\.test\.d\.ts$/.test(entry.name) || /\.spec\.[cm]?js$/.test(entry.name)) {
      fs.rmSync(fullPath, { force: true });
    }
  }
}

pruneTestArtifacts(distDir);
