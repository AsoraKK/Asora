#!/usr/bin/env node
const fs = require('node:fs');
const path = require('node:path');

const rootDir = path.join(__dirname, '..');
const distDir = path.join(rootDir, 'dist');
const srcEntry = path.join(distDir, 'src', 'index.js');
const destEntry = path.join(distDir, 'index.js');

if (!fs.existsSync(srcEntry)) {
  console.error('Expected build output missing at', srcEntry);
  process.exit(1);
}
fs.mkdirSync(distDir, { recursive: true });

// 1) Classic /api/health (zero-dependency; no imports)
const healthDir = path.join(distDir, 'health');
fs.mkdirSync(healthDir, { recursive: true });

fs.writeFileSync(
  path.join(healthDir, 'function.json'),
  JSON.stringify({
    bindings: [
      { authLevel: 'anonymous', type: 'httpTrigger', direction: 'in', name: 'req', methods: ['get'], route: 'health' },
      { type: 'http', direction: 'out', name: 'res' }
    ]
  }, null, 2)
);

fs.writeFileSync(
  path.join(healthDir, 'index.js'),
  `const H={"Content-Type":"application/json","Cache-Control":"no-store, no-cache, must-revalidate"};
module.exports=async function(context){
  let commit="unknown";
  try{ const raw=process.env.GIT_SHA||""; commit=(raw.trim()||"unknown"); }catch{}
  const payload={status:"ok",commit,service:"asora-functions",timestamp:new Date().toISOString()};
  context.res={status:200,headers:H,body:JSON.stringify(payload)};
};
`
);

// 2) Copy root metadata into dist
fs.copyFileSync(path.join(rootDir, 'host.json'), path.join(distDir, 'host.json'));
const pkg = JSON.parse(fs.readFileSync(path.join(rootDir, 'package.json'), 'utf8'));
fs.writeFileSync(
  path.join(distDir, 'package.json'),
  JSON.stringify({
    name: pkg.name,
    version: pkg.version,
    private: true,
    type: 'commonjs',
    main: 'index.js',
    engines: pkg.engines,
    dependencies: pkg.dependencies
  }, null, 2)
);

// 3) Prune tests/specs AND src/shared directories from dist (minimal health-only deployment)
//    For full-feature deployment, comment out the src/shared removal lines
(function prune(dir){
  for (const e of fs.readdirSync(dir, { withFileTypes:true })) {
    const p = path.join(dir, e.name);
        if (e.isDirectory()){
          // Remove test directories, src/, and shared/ for minimal health-only package
          if (/^(?:__tests__|tests|probe|deploy|coverage|src|shared)$/.test(e.name)) { 
            console.log('[write-dist-entry] Removing directory:', path.relative(distDir, p));
            fs.rmSync(p, { recursive:true, force:true }); 
            continue; 
          }
      prune(p); continue;
    }
    if (/\.(test|spec)\.[cm]?js$/.test(e.name) || /\.test\.d\.ts$/.test(e.name)) fs.rmSync(p, { force:true });
  }
})(distDir);

// 4) EMPTY entrypoint for v4 file-based (classic) function discovery
//    Runtime scans for function.json files automatically
//    Do NOT require or import anything here (breaks file-based discovery)
fs.writeFileSync(destEntry,
`// Auto-generated by scripts/write-dist-entry.cjs
// Empty entrypoint for v4 file-based (classic) function discovery
// Runtime scans for function.json files automatically - do NOT load handlers here
`
);
console.log('[write-dist-entry] Wrote empty v4 file-based entrypoint to', destEntry);
