---
name: E2E Integration Test

on:
  workflow_dispatch:
    inputs:
      target_environment:
        description: "Target environment for smoke checks"
        type: choice
        required: true
        default: dev
        options:
          - dev
          - staging
      function_app_name:
        description: "Optional Function App override"
        required: false
        type: string
      resource_group:
        description: "Optional Azure resource group override"
        required: false
        type: string
  workflow_run:
    workflows: ["deploy-asora-function-dev", "deploy-asora-function-staging"]
    types: [completed]
    branches: [main]

permissions:
  id-token: write
  contents: read

jobs:
  verify-secrets:
    name: Verify Required Variables
    runs-on: ubuntu-latest
    environment: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.name == 'deploy-asora-function-staging' && 'staging' || github.event.inputs.target_environment || 'dev' }}
    steps:
      - name: Ensure required variables
        env:
          AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
          AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
        run: |
          for k in AZURE_CLIENT_ID AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID; do
            v="${!k:-}"
            [ -n "$v" ] || { echo "Missing variable: $k"; exit 1; }
          done

  e2e:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    needs: verify-secrets
    runs-on: ubuntu-latest
    environment: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.name == 'deploy-asora-function-staging' && 'staging' || github.event.inputs.target_environment || 'dev' }}
    env:
      AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
      AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
      TARGET_ENV: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.name == 'deploy-asora-function-staging' && 'staging' || github.event.inputs.target_environment || 'dev' }}
      APP: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.name == 'deploy-asora-function-staging' && 'asora-function-staging' || github.event.inputs.function_app_name || (github.event.inputs.target_environment == 'staging' && 'asora-function-staging' || 'asora-function-dev') }}
      RG: ${{ github.event.inputs.resource_group || 'asora-psql-flex' }}
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4.1.7

      - name: Install jq, zip, unzip
        run: sudo apt-get update && sudo apt-get install -y jq zip unzip

      - name: Isolate AZ cache
        # Important: do NOT set AZURE_CONFIG_DIR at the job `env` level using
        # the runner context (for example, `${{ runner.temp }}`) because GitHub
        # disallows the `runner` context inside `jobs.<job_id>.env` and the
        # workflow will fail validation (Unrecognized named-value: 'runner').
        # Instead compute and export a step-level value using the runtime
        # environment variable `$RUNNER_TEMP` as shown below.
        shell: bash
        run: |
          set -euo pipefail
          DIR="$RUNNER_TEMP/azcfg-${GITHUB_RUN_ID}"
          mkdir -p "$DIR"
          echo "AZURE_CONFIG_DIR=$DIR" >> "$GITHUB_ENV"
      - name: Verify OIDC token env
        run: |
          set -euo pipefail
          test -n "${ACTIONS_ID_TOKEN_REQUEST_URL:-}" || { echo "::error::ACTIONS_ID_TOKEN_REQUEST_URL missing"; exit 1; }

      - name: Fail if legacy Azure secrets are present
        env:
          AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
        run: |
          set -euo pipefail
          [ -z "${AZURE_CREDENTIALS:-}" ] || { echo "ERROR: legacy secret AZURE_CREDENTIALS present"; exit 1; }
          [ -z "${ARM_CLIENT_SECRET:-}" ] || { echo "ERROR: legacy secret ARM_CLIENT_SECRET present"; exit 1; }

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Set Azure subscription context
        run: |
          set -euo pipefail
          az cloud set -n AzureCloud
          az account set --subscription "${AZURE_SUBSCRIPTION_ID}"
          az account show -o table

      - name: Auth sanity
        env:
          SUBS: ${{ env.AZURE_SUBSCRIPTION_ID }}
        run: |
          set -euo pipefail
          echo "AZURE_CONFIG_DIR=${AZURE_CONFIG_DIR:-$HOME/.azure}"
          ls -la "${AZURE_CONFIG_DIR:-$HOME/.azure}" || true
          az account get-access-token --resource https://management.azure.com -o none
          az account show --output table

      - name: Discover keys & URL
        id: info
        shell: bash
        env:
          SUBS: ${{ env.AZURE_SUBSCRIPTION_ID }}
          RG: ${{ env.RG }}
          APP: ${{ env.APP }}
        run: |
          set -Eeuo pipefail
          : "${SUBS:?}"; : "${RG:?}"; : "${APP:?}"

          echo "Verifying ARM access..."
          az account set --subscription "$SUBS"
          az account get-access-token --resource https://management.azure.com -o none

          APP_ID="/subscriptions/${SUBS}/resourceGroups/${RG}/providers/Microsoft.Web/sites/${APP}"
          echo "Try ARM first (more reliable across plan types)"
          APP_JSON=$(az rest --method get --url "https://management.azure.com${APP_ID}?api-version=2022-03-01" 2>arm.err || true)
          if ! jq -e . >/dev/null 2>&1 <<<"$APP_JSON"; then
            echo "::group::ARM error"; cat arm.err || true; echo "::endgroup::"
            echo "::error::Failed to GET site via ARM"; exit 1
          fi

          HOST=$(jq -r '.properties.defaultHostName // empty' <<<"$APP_JSON")
          [ -n "$HOST" ] || { echo "::error::defaultHostName not returned"; exit 1; }

          echo "FUNCTION_BASE_URL=https://${HOST}" >> "$GITHUB_ENV"
          echo "BASE_URL=https://${HOST}" >> "$GITHUB_ENV"

          echo "Attempting key discovery..."
          if KEY_JSON=$(az functionapp keys list -g "$RG" -n "$APP" 2>keys.err); then
            KEY=$(jq -r '.masterKey // .functionKeys.default // empty' <<<"$KEY_JSON")
            if [ -z "$KEY" ]; then
              echo "::warning::Function key not returned; continuing as anonymous"
            fi
          else
            if grep -q '403' keys.err 2>/dev/null; then
              echo "::warning::Function key fetch returned 403; continuing as anonymous"
              KEY=""
            else
              cat keys.err >&2 || true
              echo "::warning::Failed to fetch function keys; continuing as anonymous"
              KEY=""
            fi
          fi
          rm -f arm.err keys.err || true
          [ -n "$KEY" ] || KEY="anonymous"
          [ "$KEY" = "anonymous" ] && echo "::warning::No admin key fetched - continuing as anonymous"
          echo "FUNCTION_KEY=${KEY}" >> "$GITHUB_ENV"
          echo "Resolved deployment endpoint: https://${HOST}"

      - name: "Wait for Function App readiness"
        shell: bash
        env:
          SUBS: ${{ env.AZURE_SUBSCRIPTION_ID }}
          RG: ${{ env.RG }}
          APP: ${{ env.APP }}
        run: |
          set -euo pipefail

          APP_ID="/subscriptions/${SUBS}/resourceGroups/${RG}/providers/Microsoft.Web/sites/${APP}"
          get_state(){ az resource show --ids "$APP_ID" --query "properties.state" -o tsv 2>/dev/null || echo ""; }

          for i in $(seq 1 30); do
            STATE="$(get_state)"; echo "Attempt $i/30 state: ${STATE:-<empty>}"
            [ "$STATE" = "Running" ] && exit 0
            sleep 10
          done

          echo "::error::App not Running"; exit 1

      - name: Probe admin endpoints
        shell: bash
        env:
          FUNCTION_BASE_URL: ${{ env.FUNCTION_BASE_URL }}
          FUNCTION_KEY: ${{ env.FUNCTION_KEY }}
        run: |
          set -euo pipefail
          HOST="${FUNCTION_BASE_URL#https://}"
          KEY="${FUNCTION_KEY}"
          
          # Set up query params for authentication
          if [ "$KEY" != "anonymous" ]; then
            QP="?code=${KEY}"
          else
            QP=""
          fi
          
          echo "Probing admin endpoints on: $HOST"
          
          echo "=== GET /admin/host/status ==="
          curl -fsS "https://${HOST}/admin/host/status${QP}" | jq . || echo "Host status probe failed"
          
          echo "=== GET /admin/functions ==="
          FUNCTIONS_RESP=$(curl -fsS "https://${HOST}/admin/functions${QP}" || echo "[]")
          echo "$FUNCTIONS_RESP" | jq .
          FUNCTIONS_COUNT=$(echo "$FUNCTIONS_RESP" | jq length 2>/dev/null || echo "0")
          echo "Functions count: $FUNCTIONS_COUNT"
          
          if [ "$FUNCTIONS_COUNT" -lt 1 ]; then
            echo "::warning::Expected at least 1 function, found $FUNCTIONS_COUNT"
          fi

      - name: E2E
        shell: bash
        run: |
          set -euo pipefail
          echo "Testing Function App at: $FUNCTION_BASE_URL"

          HOST="${FUNCTION_BASE_URL#https://}"
          KEY="${FUNCTION_KEY:-anonymous}"
          QP=""
          [ "$KEY" != "anonymous" ] && QP="?code=$KEY" || QP=""

          # Discover functions up front
          FUNCS_JSON="$(curl -sS "https://${HOST}/admin/functions${QP}" || echo "[]")"
          FEED_EXISTS="$(jq -r '[.[].name] | index("feed") | if .==null then 0 else 1 end' <<<"$FUNCS_JSON" 2>/dev/null || echo 0)"
          HEALTH_EXISTS="$(jq -r '[.[].name] | index("health") | if .==null then 0 else 1 end' <<<"$FUNCS_JSON" 2>/dev/null || echo 0)"
          ADMIN_COUNT="$(jq -r 'length // 0' <<<"$FUNCS_JSON" 2>/dev/null || echo 0)"
          echo "discovered admin_count=${ADMIN_COUNT} feed_exists=${FEED_EXISTS} health_exists=${HEALTH_EXISTS}"

          ok=false
          for i in $(seq 1 60); do
            echo "Probe attempt $i/60..."

            HOST_STATE="$(curl -s "https://${HOST}/admin/host/status${QP}" | jq -r '.state // "Unknown"' 2>/dev/null || echo "Unknown")"

            # Optional endpoint checks
            FEED_STATUS="n/a"
            if [ "$FEED_EXISTS" = "1" ]; then
              FEED_STATUS="$(curl -s -o /dev/null -w "%{http_code}" "https://${HOST}/api/feed${QP}" || echo "000")"
            fi

            # Re-check admin functions count each iteration in case functions load late
            ADMIN_COUNT="$(curl -s "https://${HOST}/admin/functions${QP}" | jq -r 'length // 0' 2>/dev/null || echo 0)"

            echo "host_state=${HOST_STATE} feed_status=${FEED_STATUS}"

            # Ready when host is Running, we have at least one function,
            # and feed is OK if it exists.
            FEED_OK=true
            if [ "$FEED_EXISTS" = "1" ]; then
              if [ "$FEED_STATUS" = "200" ] || [ "$FEED_STATUS" = "204" ]; then FEED_OK=true; else FEED_OK=false; fi
            fi

            if [ "$HOST_STATE" = "Running" ] && [ "$ADMIN_COUNT" -ge 1 ] && [ "$FEED_OK" = true ]; then
              ok=true
              break
            fi

            sleep 5
          done

          if [ "$ok" != true ]; then
            echo "::error::E2E warmup failed (host_state=${HOST_STATE} feed_status=${FEED_STATUS})"
            echo "Admin host status:"; curl -sS "https://${HOST}/admin/host/status${QP}" || true
            echo "Admin functions:"; curl -sS "https://${HOST}/admin/functions${QP}" || true
            echo "Final hit to /api/health and /api/feed:"
            curl -isS "https://${HOST}/api/health${QP}" || true
            curl -isS "https://${HOST}/api/feed${QP}" || true
            exit 1
          fi

          # Optionally print current health status for visibility, but do not gate on it
          if [ "$HEALTH_EXISTS" = "1" ]; then
            echo "Health endpoint status:"; curl -isS "https://${HOST}/api/health${QP}" || true
          fi

          node scripts/e2e-itest.js

      - name: Trust endpoints smoke (receipt + passport)
        shell: bash
        env:
          BASE_URL: ${{ env.FUNCTION_BASE_URL }}
          FUNCTION_KEY: ${{ env.FUNCTION_KEY }}
        run: |
          set -euo pipefail
          chmod +x scripts/smoke-trust-endpoints.sh
          bash scripts/smoke-trust-endpoints.sh
