name: Deploy to asora-function-dev (Flex - storage publish)

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-asora-function-dev-${{ github.ref }}
  cancel-in-progress: true

env:
  AZURE_CLIENT_ID: ${{ vars.AZURE_CLIENT_ID }}
  AZURE_TENANT_ID: ${{ vars.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  RG: asora-psql-flex
  FUNC_APP: asora-function-dev
  NODE_VERSION: '20'
  DEPLOY_CONTAINER: deployments
  DEPLOY_BLOB_NAME: functionapp.zip

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: dev
    steps:
      - uses: actions/checkout@v4

      - name: Block legacy SP secrets
        env:
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
        run: |
          set -euo pipefail
          if [ -n "${AZURE_CLIENT_SECRET:-}" ] || [ -n "${AZURE_CREDENTIALS:-}" ]; then
            echo "::error::Legacy Azure SP secret present. Migrate to OIDC only." >&2
            exit 1
          fi

      - name: Install zip utilities
        run: sudo apt-get update && sudo apt-get install -y zip unzip jq

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Disable Husky in CI
        run: echo "HUSKY=0" >> "$GITHUB_ENV"

      # Build in functions/ and produce a Linux-ready dist zip without lockfile mismatch
      - name: Build function package (lockfile-safe dist)
        working-directory: functions
        run: |
          set -euo pipefail
          npm ci
          npm run build

          test -f dist/host.json || { echo "::error::dist/host.json missing"; ls -al dist; exit 1; }
          test -f dist/index.js || { echo "::error::dist/index.js missing"; ls -al dist; exit 1; }

          # Install production deps inside dist without npm ci to avoid EUSAGE on subset package.json
          if [ -f dist/package.json ]; then
            (cd dist && npm install --omit=dev --no-audit --no-fund)
          fi

          pushd dist >/dev/null
          zip -r ../dist-func.zip . -x "**/*.map" "**/*.ts" "__tests__/*" "tests/*"
          popd >/dev/null

          mv dist-func.zip "$GITHUB_WORKSPACE/dist-func.zip"

      - name: Validate package exists
        working-directory: ${{ github.workspace }}
        run: |
          set -euo pipefail
          test -f dist-func.zip || { echo "Missing dist-func.zip"; exit 3; }
          ls -lh dist-func.zip
          unzip -l dist-func.zip | head -n 40

      # Verify artifact structure for Flex Consumption deployment
      - name: Verify artifact structure (wwwroot readiness)
        working-directory: ${{ github.workspace }}
        run: |
          set -euo pipefail
          echo "=== Verifying deployment artifact structure ==="
          
          # Create temp extraction dir
          mkdir -p verify-artifact
          unzip -q dist-func.zip -d verify-artifact
          
          # Check critical files at root
          echo "Checking root files..."
          test -f verify-artifact/index.js || { echo "::error::Missing index.js at root"; exit 1; }
          test -f verify-artifact/package.json || { echo "::error::Missing package.json at root"; exit 1; }
          test -f verify-artifact/host.json || { echo "::error::Missing host.json"; exit 1; }
          
          # Verify package.json config
          echo "Verifying package.json config..."
          PKG_MAIN=$(jq -r '.main // "missing"' verify-artifact/package.json)
          PKG_TYPE=$(jq -r '.type // "missing"' verify-artifact/package.json)
          
          [[ "$PKG_MAIN" == "index.js" ]] || { echo "::error::package.json main should be index.js, got: $PKG_MAIN"; exit 1; }
          [[ "$PKG_TYPE" == "commonjs" ]] || { echo "::error::package.json type should be commonjs, got: $PKG_TYPE"; exit 1; }
          
          # Check src/ structure matches route discovery pattern
          echo "Checking route structure..."
          ROUTE_COUNT=$(find verify-artifact/src -name "*.js" -path "*/routes/*" | wc -l)
          [[ "$ROUTE_COUNT" -ge 10 ]] || { echo "::warning::Expected ≥10 route files, found $ROUTE_COUNT"; }
          
          # Verify node_modules has production deps
          echo "Checking production dependencies..."
          test -d verify-artifact/node_modules/@azure/functions || { echo "::error::Missing @azure/functions in node_modules"; exit 1; }
          test -d verify-artifact/node_modules/@azure/cosmos || { echo "::error::Missing @azure/cosmos in node_modules"; exit 1; }
          
          # List functions that will be discovered (mock test mode)
          echo "=== Simulating route discovery ==="
          cd verify-artifact
          timeout 5 node index.js 2>&1 | grep -E "(WARNING|register function)" | tee ../function-discovery.log || true
          
          # Verify expected function count
          DISCOVERED_COUNT=$(grep -c "register function" ../function-discovery.log || echo "0")
          echo "Discovered $DISCOVERED_COUNT functions"
          [[ "$DISCOVERED_COUNT" -ge 10 ]] || { echo "::warning::Expected ≥10 functions, discovered $DISCOVERED_COUNT"; }
          
          cd "$GITHUB_WORKSPACE"
          rm -rf verify-artifact
          
          echo "✅ Artifact structure verification passed"

      # A) Resolve storage and prepare container (validates non-HNS, exports STG)
      - name: Resolve storage and prepare container
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail
            CONTAINER="${DEPLOY_CONTAINER}"
            re='^[a-z0-9]([a-z0-9-]{1,61}[a-z0-9])?$'
            [[ "$CONTAINER" =~ $re && "$CONTAINER" != *--* ]] || { echo "::error::Invalid container name: $CONTAINER"; exit 1; }

            SA=$(az functionapp config appsettings list -g "$RG" -n "$FUNC_APP" \
                  --query "[?name=='AzureWebJobsStorage__accountName'].value|[0]" -o tsv)
            if [ -z "$SA" ] || [ "$SA" = "None" ]; then
              CS=$(az functionapp config appsettings list -g "$RG" -n "$FUNC_APP" \
                    --query "[?name=='AzureWebJobsStorage'].value|[0]" -o tsv)
              SA=$(echo "$CS" | sed -n 's/.*AccountName=\([^;]*\).*/\1/p')
            fi
            [ -n "$SA" ] || { echo "::error::AzureWebJobsStorage account not resolved"; exit 1; }

            HNS=$(az storage account show --name "$SA" --query isHnsEnabled -o tsv)
            [ "$HNS" != "true" ] || { echo "::error::Storage '$SA' has HNS enabled; use non-HNS for deployments."; exit 1; }

            az storage account show --name "$SA" >/dev/null
            az storage container create --account-name "$SA" --name "$CONTAINER" --auth-mode login >/dev/null || true

            echo "STG=$SA" >> "$GITHUB_ENV"

      # B) Grant RBAC to GitHub OIDC principal for blob upload
      - name: Grant OIDC RBAC on storage
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail
            : "${STG:?STG not set}"
            SCOPE=$(az storage account show --name "$STG" --query id -o tsv)
            APP_OBJ_ID=$(az ad sp show --id "$AZURE_CLIENT_ID" --query id -o tsv)
            [ -n "$APP_OBJ_ID" ] || { echo "::error::AZURE_CLIENT_ID not resolvable to service principal"; exit 1; }

            az role assignment create --assignee-object-id "$APP_OBJ_ID" \
              --assignee-principal-type ServicePrincipal \
              --role "Storage Blob Data Contributor" --scope "$SCOPE" 2>/dev/null || true
            sleep 15

      # C) Patch runtime without breaking deployment.storage (merge current config)
      - name: Ensure Flex runtime + memory (merge-patch)
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail
            az functionapp show -g "$RG" -n "$FUNC_APP" --query properties.functionAppConfig -o json > cur.json
            python3 - <<'PY' > body.json
            import json
            with open("cur.json") as f:
              cfg=json.load(f)
            if not isinstance(cfg, dict): cfg={}
            cfg.setdefault("runtime",{})["name"]="node"
            cfg["runtime"]["version"]="20"
            sc=cfg.get("scaleAndConcurrency") or {}
            sc["instanceMemoryMB"]=2048
            sc.setdefault("maximumInstanceCount",40)
            cfg["scaleAndConcurrency"]=sc
            cfg["siteUpdateStrategy"]={"type":"Recreate"}
            print(json.dumps({"properties":{"functionAppConfig":cfg}}))
            PY
            az functionapp config appsettings set -g "$RG" -n "$FUNC_APP" --settings FUNCTIONS_EXTENSION_VERSION="~4" >/dev/null
            az rest --method patch \
              --uri "/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$RG/providers/Microsoft.Web/sites/$FUNC_APP?api-version=2023-12-01" \
              --body @body.json >/dev/null

      # D) Grant Function App MI Storage Blob Data Reader
      - name: Grant Function App MI Storage Blob Data Reader
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail
            : "${STG:?STG not set}"
            SA_ID=$(az storage account show --name "$STG" --query id -o tsv)
            MI_PRINCIPAL_ID=$(az functionapp identity show -g "$RG" -n "$FUNC_APP" --query principalId -o tsv)
            
            az role assignment create \
              --assignee-object-id "$MI_PRINCIPAL_ID" \
              --assignee-principal-type ServicePrincipal \
              --role "Storage Blob Data Reader" \
              --scope "$SA_ID" 2>/dev/null || echo "RBAC already present"
            
            sleep 30  # RBAC propagation

      # E) Upload and publish from storage
      - name: Upload package to storage
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail
            : "${STG:?STG not set}"
            az storage blob upload --auth-mode login \
              --account-name "$STG" --container-name "$DEPLOY_CONTAINER" \
              --name "$DEPLOY_BLOB_NAME" --file "$GITHUB_WORKSPACE/dist-func.zip" --overwrite

      # Publish to Flex using ARM /publish with a short-lived SAS to the uploaded blob
      - name: Publish package via ARM /publish (Flex)
        uses: azure/cli@v2
        with:
          inlineScript: |
            set -euo pipefail
            : "${STG:?STG not set}"

            EXPIRY=$(date -u -d "+1 hour" +"%Y-%m-%dT%H:%MZ")
            SAS=$(az storage blob generate-sas \
              --account-name "$STG" \
              --container-name "$DEPLOY_CONTAINER" \
              --name "$DEPLOY_BLOB_NAME" \
              --permissions r \
              --expiry "$EXPIRY" -o tsv)

            PACKAGE_URI="https://$STG.blob.core.windows.net/$DEPLOY_CONTAINER/$DEPLOY_BLOB_NAME?$SAS"
            echo "Using package URI: ${PACKAGE_URI%%\?*}?(redacted)"

            printf '{"properties":{"packageUri":"%s"}}\n' "$PACKAGE_URI" > body.json
            az rest --method post \
              --uri "/subscriptions/$AZURE_SUBSCRIPTION_ID/resourceGroups/$RG/providers/Microsoft.Web/sites/$FUNC_APP/publish?api-version=2023-12-01" \
              --body @body.json

            echo "Waiting 60s for function discovery..."
            sleep 60

      - name: List deployed functions
        uses: azure/cli@v2
        with:
          inlineScript: |
            echo "Listing deployed functions:"
            az functionapp function list -g "$RG" -n "$FUNC_APP" -o table


      - name: Smoke test HTTP trigger
        run: |
          set -euo pipefail
          
          MAX_ATTEMPTS=8
          SLEEP_INTERVAL=10
          HEALTH_URL="https://${FUNC_APP}.azurewebsites.net/api/health"
          
          echo "Testing health endpoint: $HEALTH_URL"
          
          for i in $(seq 1 $MAX_ATTEMPTS); do
            echo "Attempt $i/$MAX_ATTEMPTS..."
            
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || echo "000")
            
            if [[ "$HTTP_CODE" == "200" ]]; then
              echo "✅ Health check passed (HTTP $HTTP_CODE)"
              RESPONSE=$(curl -s "$HEALTH_URL")
              echo "Response: $RESPONSE"
              exit 0
            else
              echo "❌ Health check returned HTTP $HTTP_CODE"
              if [[ $i -lt $MAX_ATTEMPTS ]]; then
                echo "Waiting ${SLEEP_INTERVAL}s before retry..."
                sleep $SLEEP_INTERVAL
              fi
            fi
          done
          
          echo "::error::Health check failed after $MAX_ATTEMPTS attempts (80s wait)"
          exit 1

      - name: Display function URLs
        run: |
          echo "Deployed function URLs:"
          echo "  Health: https://${FUNC_APP}.azurewebsites.net/health (or /api/health)"
          echo "  Feed:   https://${FUNC_APP}.azurewebsites.net/feed (or /api/feed)"

      # Post-deployment validation with k6
      - name: Setup k6
        uses: grafana/setup-k6-action@v1

      - name: Post-deployment smoke test (health)
        env:
          K6_BASE_URL: https://${{ env.FUNC_APP }}.azurewebsites.net
          VUS: '1'
          DURATION: '30s'
        run: k6 run load/k6/smoke.js

      - name: Post-deployment feed read test
        env:
          K6_BASE_URL: https://${{ env.FUNC_APP }}.azurewebsites.net
          VUS: '5'
          DURATION: '60s'
        run: k6 run load/k6/feed-read.js

      - name: Upload k6 summaries
        uses: actions/upload-artifact@v4
        if: always()  # Upload even if k6 fails
        with:
          name: k6-summaries-${{ github.run_id }}
          path: load/k6/*-summary.json
          if-no-files-found: warn
